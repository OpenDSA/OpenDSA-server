Author: Kyle Reinholt 
Date Created: 6/22/15
***

Files for the Java-Version of OPT Visualizer 
============================================

These are files needed for the back and frontend of the Java version of Online Python Tutor. Also included, is a program used specifically for OpenDSA exercises that extracts crucial code from the input pane before the program visualization is activated. Once code is submitted on the frontend on a given pointers exercise on the OpenDSA frontend, the code will be sent to the backend. Files within the backendFiles directory will filter out the students code and return a visualization trace in a javaScript file. The contents of this file will then be sent back to the OpenDSA frontend to be displayed to the user. 

The frontend files were included here for examples of how to integrate them into the OpenDSA system.  

DEVELOPER OVERVIEW
==================

Author: Kyle Reinholt 
Date: 7/30/2015
Contact: If you have any questions email me at (reinholtk24@mycu.concord.edu)
In order to get the modified version of Online Python Tutor (OPT) for OpenDSA pointer exercises follow these instructions: 
BACKEND
=======
 
To understand how the backend for Python Tutor works, read this excerpt from Philip Guo’s article about Python Tutor. Source: Guo, Philip J. "Online python tutor: embeddable web-based program visualization for cs education." Proceeding of the 44th ACM technical symposium on Computer science education. ACM, 2013. 

“The Online Python Tutor backend takes the source code of a Python program as input and produces an execution trace as output. The backend executes the input program under supervision of the standard Python debugger module (bdb), which stops execution after every executed line and records the program’s run-time state. The trace is an ordered list of execution points, where each point contains the state right before a line of code is about to execute, including: 
• The line number of the line that is about to execute, 
• the instruction type (ordinary single step, exception, function call, or function return), 
• a map of global variable names to their current values at this execution point, 
• an ordered list of stack frames, where each frame contains a map of local variable names to current values, 
• the current state of the heap, 
• and the program’s output up to this execution point. 
After execution terminates, the backend encodes the trace in JSON format, serializing Python data types into native JSON types with extra metadata tags. To guard against infinite loops and excessively long traces, the backend halts execution after 300 executed lines. Although this limit is tiny for real programs, it is sufficient for the pedagogical code examples that our users want to visualize. Note that the trace contains a great deal of redundancy, since it stores a complete snapshot of the stack and heap at every execution point. Traces from pedagogical code examples range from 10KB to 200KB in size. We have not found backend running times or trace sizes to be performance bottlenecks in practice and thus have not yet attempted to optimize. The backend works with both Python 2 and 3, which is important because courses are taught using both of these major language variants. The backend can be hosted on any webserver capable of running CGI scripts (using Python 2 or 3) or on the Google App Engine platform (Python 2.7). When the user’s web browser makes an HTTP GET request to the backend and passes in the Python program to visualize, the backend generates a trace and returns it to the browser in JSON format. Since the backend is running untrusted Python code from the web, it implements sandboxing to prevent the execution of dangerous constructs such as eval, exec, file I/O, and most module imports (except for a customizable whitelist of modules such as math). In addition, many webservers implement “defense in depth” for additional protections. However, we have not yet conducted a formal security audit.” – Philip Guo 

To learn more about the execution traces that are generated by the backend, look over the documentation from the Python Tutor repository here: 
https://github.com/pgbovine/OnlinePythonTutor/blob/master/v3/docs/opt-trace-format.md
Now I will describe the steps I took to isolate sections of code for visualization. 
The steps I took. 

1. Get the backend traceprinter system (OPT – Java backend system). 
This can be done by going to https://github.com/daveagp/java_jail and following the installation instructions. 

You will also need to install Java as explained on https://github.com/daveagp/java_jail in order for the traceprinter package to run.

2. Get the jsonFilter or get the whole package minus the Java package (I could not push the entire Java package onto github because it exceeded the maximum memory for the repository) at https://github.com/OpenDSA/OpenPOP/tree/master/Java-Visualizer . The jsonFilter is the file that will take in the JUnit test file from the OpenDSA exercise and generate the backend trace json object by using the traceprinter package. 
***
<b>IMPORTANT!</b> 
For each OpenDSA exercise, you must insert the flags startTraceNow(); and endTraceNow(); around the code intended for visualization. This is how the jsonFilter locates the section of code to be displayed. It saves all of the execution traces after startTraceNow and stops saving them once endTraceNow(); is found. For an example of how this works, check out pntrequalspntrPART1.java and pntrequalspntrPART2.java on the OpenDSA-beta backend system. On the last line in the PART1 file you must add the function startTraceNow(); Moreover, for the first line of code in the PART2 file, you must include endTraceNow(); This is because once a student submits code on the OpenDSA exercise, the students code is appended onto the PART1 file and then PART2 is appended onto the student code. Thus, wrapping the student code inside of PART1 and PART2. If the last line of code in PART1 is startTraceNow(); and the first line of code in PART2 is endTraceNow(); the student code will be packaged successfully for visualization. For example, 

PART1.java
        
        //code 
        startTraceNow();  ----> this starts the jsonFilter
        // end of PART1.java
        Student Code      // The jsonFilter will save these execution traces and output them in js  
  
PART2.java

        endTraceNow(); -----> this ends the jsonFilter
        // code 
        // end of PART2.java

The jsonFilter will run the Junit test file through the traceprinter and filter out the execution traces corresponding to the students’ code. You can save the JavaScript file that is used for visualization with a variable and send it back to the frontend system. The entire visualizer GUI is encapsulated in a JavaScript ExecutionVisualizer class. This class is contained in this JavaScript string in a format similar to this:  

        ExecutionVisualizer(parentNode, trace); 

parentNode is the HTML DOM element where the visualizer instance should be embedded. In order to visualize you must include the parentNode in the <div>’parentNode’<div> inside the HTML file. Here is an example of how to obtain the contents of the javaScript file necessary to visualize the code.

        #This is an example of how to use the seperateAndFilterTrace() function. This 
        #function initiates everything. Include this in your python code with the proper 
        #parameters to get expected results. myTest is a string that contains the entire js file contents for visualizing isolated student code.
        #Send this string to the correct frontend directory, make a javaScript file and only containing myTest, then include the
        # proper links and scripts in the html page and you should be good to go. 

        myTest = seperateAndFilterTrace(" jUnitTestFile", "filesPath", "peruserFilesPath", "studentfilename")

        //(This is described with in code documentation within the jsonFilter.py file). 


FRONTEND
========

3. This repository contains the modified frontend files for Online Python Tutor that you will need for visualizing code with OPT.  https://github.com/OpenDSA/OpenPOP/tree/master/Java-Visualizer
pytutor.js and pytutor.css are the two main files you use to change the layout and display of the submitted code.  These two files were slightly modified to produce the current display and layout for the OpenDSA pointer exercises. Class objects, lists, and trees are loaded to the screen using JavaScript in CSS in Python Tutor. Pytutor.js reads in the execution traces and produces the visualizations. All of the code for adjusting the static analysis and display of the program is in pytutor.js and pytutor.css. 

Modifying the Display/Layout Dynamically
========================================

It appears that the pytutor.js file contains analysis for objects in Python such as LIST, TUPLE, DICT, and SET (the lines of code that contain this functionality are around line 3300). However, if these types of structures are initiated using a custom class, they are interpreted as custom class objects and the construction of the layout is handled differently. I tried manipulating the code within the custom object functionality to resemble the layout of the LIST layout but was unsuccessful. There is something about the composition of the display I am overlooking...


